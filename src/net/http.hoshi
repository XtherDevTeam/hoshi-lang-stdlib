use lang "builtin"
use io "io"
use hashMap "hashMap"
use str "str"
use vec "vec"
use runtime "runtime"
use math "math"
use file "file"
use socket "socket"
use uri "uri"
use console "console"

struct HTTPRequestHeader {
    method: str.Str,
    target: str.Str,
    version: str.Str,
    headers: hashMap.HashMap<str.Str, str.Str>,
    constructor(method: str.Str, target: str.Str, version: str.Str, headers: hashMap.HashMap<str.Str, str.Str>),
    to_string() : str.Str,
    add_header(key: str.Str, value: str.Str) : HTTPRequestHeader
}

struct HTTPResponseHeader {
    version: str.Str,
    status_code: int,
    status_message: str.Str,
    headers: hashMap.HashMap<str.Str, str.Str>,
    constructor(version: str.Str, status_code: int, status_message: str.Str, headers: hashMap.HashMap<str.Str, str.Str>),
    to_string() : str.Str,
    add_header(key: str.Str, value: str.Str) : HTTPResponseHeader
}

impl HTTPRequestHeader {
    constructor(method: str.Str, target: str.Str, version: str.Str, headers: hashMap.HashMap<str.Str, str.Str>) {
        this.method = method
        this.target = target
        this.version = version
        this.headers = headers
    },
    to_string() : str.Str {
        let first_line = str.format("{} {} {}\r\n", this.method, this.target, this.version)
        let headers : str.Str = ""
        for (let i = 0; i < this.headers.size(); i += 1) {
            headers += str.format("{}: {}\r\n", this.headers.keys()[i], this.headers.values()[i])
        }
        return str.format("{}{}{}", first_line, headers, "\r\n")
    },
    add_header(key: str.Str, value: str.Str) : HTTPRequestHeader {
        this.headers[key.lowercase()] = value
        return this
    }
}

impl HTTPResponseHeader {
    constructor(version: str.Str, status_code: int, status_message: str.Str, headers: hashMap.HashMap<str.Str, str.Str>) {
        this.version = version
        this.status_code = status_code
        this.status_message = status_message
        this.headers = headers
    },
    to_string() : str.Str {
        let first_line = str.format("{} {} {}\r\n", this.version, this.status_code, this.status_message)
        let headers : str.Str = ""
        for (let i = 0; i < this.headers.size(); i += 1) {
            headers += str.format("{}: {}\r\n", this.headers.keys()[i], this.headers.values()[i])
        }
        return str.format("{}{}{}", first_line, headers, "\r\n")
    },
    add_header(key: str.Str, value: str.Str) : HTTPResponseHeader {
        this.headers[key.lowercase()] = value
        return this
    }
}

impl HTTPRequestHeader : str.Stringable {
    to_string() : str.Str {
        return this.to_string()
    }
}

impl HTTPResponseHeader : str.Stringable {
    to_string() : str.Str {
        return this.to_string()
    }
}

enum HTTPHeaderParseError {
    NO_FIRST_LINE,
    INVALID_METHOD,
    INVALID_TARGET,
    INVALID_VERSION,
    INVALID_STATUS_CODE,
    INVALID_STATUS_MESSAGE
}

func parseHTTPRequestHeader(s: str.Str) : lang.Result<HTTPRequestHeader, HTTPHeaderParseError> {
    let first_line_end = s.find("\r\n")
    if (first_line_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.NO_FIRST_LINE)
    }
    let first_line = s.substring(0, first_line_end)
    let method_end = first_line.find(" ")
    if (method_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_METHOD)
    }
    let method = first_line.substring(0, method_end)
    let target_start = method_end + 1
    let target_end = first_line.find(" ", target_start)
    if (target_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_TARGET)
    }
    let target = first_line.substring(target_start, target_end)
    let version_start = target_end + 1
    if (version_start >= first_line.length) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_VERSION)
    }
    let version = first_line.substring(version_start, first_line.length)
    let headers = hashMap.HashMap<str.Str, str.Str>()
    let header_start = first_line_end + 2
    while (header_start < s.length) {
        let header_end = s.find("\r\n", header_start)
        if (header_end == -1) {
            break
        }
        let header_line = s.substring(header_start, header_end)
        let colon_index = header_line.find(":")
        if (colon_index == -1) {
            break
        }
        let header_name = header_line.substring(0, colon_index).lowercase()
        let header_value = header_line.substring(colon_index + 1, header_line.length)
        headers[header_name] = header_value
        header_start = header_end + 2
    }
    return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.ok(HTTPRequestHeader(method, target, version, headers))
}

func parseHTTPResponseHeader(s: str.Str) : lang.Result<HTTPResponseHeader, HTTPHeaderParseError> {
    let first_line_end = s.find("\r\n")
    let first_line = s.substring(0, first_line_end)
    let version_start = 0
    let version_end = first_line.find(" ")
    if (version_end == -1) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_VERSION)
    }
    let version = first_line.substring(version_start, version_end)
    let status_code_start = version_end + 1
    let status_code_end = first_line.find(" ", status_code_start)
    if (status_code_end == -1) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_STATUS_CODE)
    }
    let status_code = str.toInt(first_line.substring(status_code_start, status_code_end))
    let status_message_start = status_code_end + 1
    if (status_message_start >= first_line.length) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_STATUS_MESSAGE)
    }
    let status_message = first_line.substring(status_message_start, first_line.length)
    let headers = hashMap.HashMap<str.Str, str.Str>()
    let header_start = first_line_end + 2
    while (header_start < s.length) {
        let header_end = s.find("\r\n", header_start)
        if (header_end == -1) {
            break
        }
        let header_line = s.substring(header_start, header_end)
        let colon_index = header_line.find(":")
        if (colon_index == -1) {
            break
        }
        let header_name = header_line.substring(0, colon_index).lowercase()
        let header_value = header_line.substring(colon_index + 2, header_line.length)
        headers[header_name] = header_value
        header_start = header_end + 2
    }
    return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.ok(HTTPResponseHeader(version, status_code, status_message, headers))
}

interface HTTPRequestBody {
    contentLength() : int,
    contentType() : str.Str,
    writeTo(writer: socket.AbstractSocket) : none
}

enum HTTPNetworkError {
    SUCCESS,
    INVALID_URI,
    UNKNOWN_PROTOCOL,
    NAME_NOT_RESOLVED,
    CONNECTION_REFUSED,
    CONNECTION_RESET,
    CONNECTION_TIMEOUT,
    INVALID_HTTP_RESPONSE,
    UNKNOWN_ERROR
}

struct HTTPResponse {
    resource: uri.URL,
    header: HTTPResponseHeader,
    socket: socket.AbstractSocket,
    cached_recv: io.ArrayBuffer,
    constructor(resource: uri.URL, header: HTTPResponseHeader, socket: socket.AbstractSocket, cached_recv: io.ArrayBuffer),
    iterate_chunk() : io.ArrayBuffer,
    getch() : char,
    recv_next_raw_response() : lang.Result<io.ArrayBuffer, HTTPNetworkError>,
    recv_text() : lang.Result<str.Str, HTTPNetworkError>
}

struct HTTPRequest {
    resource: uri.URL,
    header: HTTPRequestHeader,
    socket: socket.AbstractSocket,
    body: HTTPRequestBody,
    cached_recv: io.ArrayBuffer,
    constructor(resource: uri.URL, header: HTTPRequestHeader, body: HTTPRequestBody),
    constructor(resource: uri.URL, header: HTTPRequestHeader),
    send() : lang.Result<HTTPResponse, HTTPNetworkError>,
    set_body(body: HTTPRequestBody) : HTTPRequest,
    set_header(key: str.Str, value: str.Str) : HTTPRequest,
    recv_header() : lang.Result<HTTPResponseHeader, HTTPNetworkError>,
    patch_header() : HTTPRequest,
}

impl HTTPResponse {
    constructor(resource: uri.URL, header: HTTPResponseHeader, socket: socket.AbstractSocket, cached_recv: io.ArrayBuffer) {
        this.resource = resource
        this.header = header
        this.socket = socket
        this.cached_recv = cached_recv
        this.resource
    },
    recv_next_raw_response() : lang.Result<io.ArrayBuffer, HTTPNetworkError> {
        let resp = this.socket.recv(1024u)
        if (resp.is_err()) {
            return lang.Result<io.ArrayBuffer, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
        }
        let buf = resp.unwrap()
        if (buf.size == 0) {
            return lang.Result<io.ArrayBuffer, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
        }
        this.cached_recv = buf
        return lang.Result<io.ArrayBuffer, HTTPNetworkError>.ok(buf)
    },
    getch() : char {   
        if (this.cached_recv.current_pos >= this.cached_recv.size) {
            let result = this.recv_next_raw_response()
            if (result.is_err()) {
                return '\0'
            }
            result.unwrap()
        }
        let ret = this.cached_recv.buf[this.cached_recv.current_pos]
        this.cached_recv.current_pos += 1
        return ret
    },
    iterate_chunk() : io.ArrayBuffer {
        if (this.header.headers.contains("transfer-encoding") == false || this.header.headers["transfer-encoding"] != "chunked") {
            runtime.puts("Invalid transfer-encoding")
            return null
        }
        let chunk_size = 0
        let current_ch = this.getch()
        while ((current_ch >= '0' && current_ch <= '9') || (current_ch >= 'a' && current_ch <= 'f') || (current_ch >= 'A' && current_ch <= 'F')) {
            chunk_size = chunk_size * 16 + math.hextoint(current_ch)
            current_ch = this.getch()
        }
        if (current_ch != '\r' || this.getch() != '\n') {
            runtime.puts("Invalid \\r\\n")
            return null
        }
        let chunk_data = io.ArrayBuffer(chunk_size)
        let current_pos = 0
        // if chunk size is larger than the remaining data, we need to read more data from the socket, but before that, we read the remaining data into the chunk buffer
        runtime.memcpy(runtime.runtime_get_string_array_data_pointer(chunk_data.buf), runtime.runtime_get_string_array_data_pointer(this.cached_recv.buf) + this.cached_recv.current_pos, this.cached_recv.size - this.cached_recv.current_pos)
        current_pos = this.cached_recv.size - this.cached_recv.current_pos
        while (current_pos < chunk_size) {
            let result = this.recv_next_raw_response()
            if (result.is_err()) {
                runtime.puts("Cannot iterate next raw response")
                return null
            }
            let buf = result.unwrap()
            if (buf.size == 0) {
                runtime.puts("Premature end of chunked encoding")
                return null
            }
            // if current_pos + buf.size is larger than chunk_size, we need to move its position to the end_pos and break
            let actual_read = math.min(chunk_size - current_pos, buf.size)
            runtime.memcpy(runtime.runtime_get_string_array_data_pointer(chunk_data.buf) + current_pos, runtime.runtime_get_string_array_data_pointer(buf.buf), actual_read)
            current_pos += actual_read
            if (actual_read < buf.size) {
                this.cached_recv.current_pos = actual_read
                break
            }
        }
        // all data received, return
        if (this.getch() != '\r' || this.getch() != '\n') {
            runtime.puts("Invalid \\r\\n in chunked encoding")
            return null
        }
        return chunk_data
    },
    recv_text() : lang.Result<str.Str, HTTPNetworkError> {
        // check if chunked encoding is used
        if (this.header.headers.contains("transfer-encoding") != false && this.header.headers["transfer-encoding"] == "chunked") {
            let final = str.Str(1024u)
            while (true) {
                let chunk = this.iterate_chunk()
                if (chunk == null) {
                    break
                }
                if (chunk.size == 0) {
                    break
                }
                console.print("Received chunked data length:", chunk.size as int, "\n")
                final += chunk.buf
            }
            return lang.Result<str.Str, HTTPNetworkError>.ok(final)
        } elif (this.header.headers.contains("content-length") != false) {
            let content_length = str.toInt(this.header.headers["content-length"])
            if (content_length == 0) {
                return lang.Result<str.Str, HTTPNetworkError>.ok("")
            }
            let content = str.Str(content_length as unsigned)
            let current_pos = 0
            while (current_pos < content_length) {
                let result = this.recv_next_raw_response()
                if (result.is_err()) {
                    return lang.Result<str.Str, HTTPNetworkError>.err(result.unwrap_err())
                }
                let buf = result.unwrap()
                if (buf.size == 0) {
                    return lang.Result<str.Str, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
                }
                let actual_read = math.min((content_length - current_pos) as unsigned, buf.size as unsigned)
                runtime.memcpy(runtime.runtime_get_string_array_data_pointer(content.data) + current_pos, runtime.runtime_get_string_array_data_pointer(buf.buf), actual_read)
                current_pos += actual_read
                if (actual_read < buf.size) {
                    this.cached_recv.current_pos = actual_read
                    break
                }
            }
            content.length = content_length
            return lang.Result<str.Str, HTTPNetworkError>.ok(content)
        } else {
            return lang.Result<str.Str, HTTPNetworkError>.err(HTTPNetworkError.INVALID_HTTP_RESPONSE)
        }
    }
}

impl HTTPRequest {
    constructor(resource: uri.URL, header: HTTPRequestHeader, body: HTTPRequestBody) {
        this.header = header
        this.body = body
        this.resource = resource
    },
    constructor(resource: uri.URL, header: HTTPRequestHeader) {
        this.header = header
        this.resource = resource
    },
    patch_header() : HTTPRequest {
        if (this.header.headers.contains("content-length") == false && this.body != null) {
            this.header.add_header("content-length", str.Stringable(this.body.contentLength()).to_string())
        }
        if (this.header.headers.contains("content-type") == false && this.body != null) {
            this.header.add_header("content-type", this.body.contentType())
        }
        if (this.header.headers.contains("host") == false) {
            this.header.add_header("host", this.resource.host)
        }
        if (this.header.headers.contains("user-agent") == false) {
            this.header.add_header("user-agent", "hoshi-libhttp/0.1; JerryChou;")
        }
        return this
    },
    send() : lang.Result<HTTPResponse, HTTPNetworkError> {
        let host = socket.resolve_name(this.resource.host)
        if (host.is_err()) {
            return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.NAME_NOT_RESOLVED)
        }
        if (this.resource.protocol == "https") {
            let result = socket.ssl_socket()
            if (result.is_err()) {
                return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_REFUSED)
            }
            this.socket = result.unwrap()
        } elif (this.resource.protocol == "http") {
            let result = socket.socket()
            if (result.is_err()) {
                return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_REFUSED)
            }
            this.socket = result.unwrap()
        } else {
            return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.UNKNOWN_PROTOCOL)
        }
        if (this.socket.connect(host.unwrap(), this.resource.port) != 0) {
            return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_REFUSED)
        }

        this.patch_header()
        let head = this.header.to_string()
        this.socket.send(head.data, head.length)
        if (this.body != null) {
            this.body.writeTo(this.socket)
        }
        let header_result = this.recv_header()
        if (header_result.is_err()) {
            return lang.Result<HTTPResponse, HTTPNetworkError>.err(header_result.unwrap_err())
        }
        let header = header_result.unwrap()
        return lang.Result<HTTPResponse, HTTPNetworkError>.ok(HTTPResponse(this.resource, header, this.socket, this.cached_recv))
    },
    recv_header() : lang.Result<HTTPResponseHeader, HTTPNetworkError> {
        // no cache buffer will ever be set before this
        let recv_s = str.Str(1024u)
        let need_push = true
        while (true) {
            let recv = this.socket.recv(1024u)
            if (recv.is_err()) {
                return lang.Result<HTTPResponseHeader, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
            }
            let buf = recv.unwrap()
            if (buf.size == 0) {
                return lang.Result<HTTPResponseHeader, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
            }
            for (let i = 0; i < buf.size - 4; i += 1) {
                if (buf.buf[i] == 13 && buf.buf[i+1] == 10 && buf.buf[i+2] == 13 && buf.buf[i+3] == 10) {
                    buf.current_pos = i + 4
                    need_push = false
                    break
                } else {
                    recv_s.push(buf.buf[i])
                }
            }
            if (need_push) {
                recv_s.push(buf.buf[buf.current_pos])
                recv_s.push(buf.buf[buf.current_pos+1])
                recv_s.push(buf.buf[buf.current_pos+2])
                recv_s.push(buf.buf[buf.current_pos+3])
                buf.current_pos += 4
            }
            if (buf.current_pos < buf.size) {
                this.cached_recv = buf
                break
            }
        }
        let header_result = parseHTTPResponseHeader(recv_s)
        if (header_result.is_err()) {
            return lang.Result<HTTPResponseHeader, HTTPNetworkError>.err(HTTPNetworkError.INVALID_HTTP_RESPONSE)
        }
        return lang.Result<HTTPResponseHeader, HTTPNetworkError>.ok(header_result.unwrap())
    },
    set_body(body: HTTPRequestBody) : HTTPRequest {
        this.body = body
        return this
    },
    set_header(key: str.Str, value: str.Str) : HTTPRequest {
        this.header.add_header(key, value)
        return this
    }
}

func open(method: str.Str, url: str.Str, headers: hashMap.HashMap<str.Str, str.Str>, body: HTTPRequestBody) : lang.Result<HTTPRequest, HTTPNetworkError> {
    let uri_result = uri.parseURL(url)
    if (uri_result.is_err()) {
        return lang.Result<HTTPRequest, HTTPNetworkError>.err(HTTPNetworkError.INVALID_URI)
    }
    let header = HTTPRequestHeader(method, uri_result.unwrap().target, "HTTP/1.1", headers)
    return lang.Result<HTTPRequest, HTTPNetworkError>.ok(HTTPRequest(uri_result.unwrap(), header, body))
}

func open(method: str.Str, url: str.Str) : lang.Result<HTTPRequest, HTTPNetworkError> {
    let uri_result = uri.parseURL(url)
    if (uri_result.is_err()) {
        return lang.Result<HTTPRequest, HTTPNetworkError>.err(HTTPNetworkError.INVALID_URI)
    }
    let header = HTTPRequestHeader(method, uri_result.unwrap().target, "HTTP/1.1", hashMap.HashMap<str.Str, str.Str>())
    return lang.Result<HTTPRequest, HTTPNetworkError>.ok(HTTPRequest(uri_result.unwrap(), header))
}
use lang "builtin"
use io "io"
use hashMap "hashMap"
use str "str"
use vec "vec"
use runtime "runtime"
use math "math"
use file "file"
use socket "socket"
use uri "uri"

struct HTTPRequestHeader {
    method: str.Str,
    target: str.Str,
    version: str.Str,
    headers: hashMap.HashMap<str.Str, str.Str>,
    constructor(method: str.Str, target: str.Str, version: str.Str, headers: hashMap.HashMap<str.Str, str.Str>),
    to_string() : str.Str,
    add_header(key: str.Str, value: str.Str) : HTTPRequestHeader
}

struct HTTPResponseHeader {
    version: str.Str,
    status_code: int,
    status_message: str.Str,
    headers: hashMap.HashMap<str.Str, str.Str>,
    constructor(version: str.Str, status_code: int, status_message: str.Str, headers: hashMap.HashMap<str.Str, str.Str>),
    to_string() : str.Str,
    add_header(key: str.Str, value: str.Str) : HTTPResponseHeader
}

impl HTTPRequestHeader {
    constructor(method: str.Str, target: str.Str, version: str.Str, headers: hashMap.HashMap<str.Str, str.Str>) {
        this.method = method
        this.target = target
        this.version = version
        this.headers = headers
    },
    to_string() : str.Str {
        let first_line = str.format("{} {} {}\r\n", this.method, this.target, this.version)
        let headers : str.Str = ""
        for (let i = 0; i < this.headers.size(); i += 1) {
            headers += str.format("{}: {}\r\n", this.headers.keys()[i], this.headers.values()[i])
        }
        return str.format("{}{}{}", first_line, headers, "\r\n")
    },
    add_header(key: str.Str, value: str.Str) : HTTPRequestHeader {
        this.headers[key.lowercase()] = value
        return this
    }
}

impl HTTPResponseHeader {
    constructor(version: str.Str, status_code: int, status_message: str.Str, headers: hashMap.HashMap<str.Str, str.Str>) {
        this.version = version
        this.status_code = status_code
        this.status_message = status_message
        this.headers = headers
    },
    to_string() : str.Str {
        let first_line = str.format("{} {} {}\r\n", this.version, this.status_code, this.status_message)
        let headers : str.Str = ""
        for (let i = 0; i < this.headers.size(); i += 1) {
            headers += str.format("{}: {}\r\n", this.headers.keys()[i], this.headers.values()[i])
        }
        return str.format("{}{}{}", first_line, headers, "\r\n")
    },
    add_header(key: str.Str, value: str.Str) : HTTPResponseHeader {
        this.headers[key.lowercase()] = value
        return this
    }
}

impl HTTPRequestHeader : str.Stringable {
    to_string() : str.Str {
        return this.to_string()
    }
}

impl HTTPResponseHeader : str.Stringable {
    to_string() : str.Str {
        return this.to_string()
    }
}

enum HTTPHeaderParseError {
    NO_FIRST_LINE,
    INVALID_METHOD,
    INVALID_TARGET,
    INVALID_VERSION,
    INVALID_STATUS_CODE,
    INVALID_STATUS_MESSAGE
}

func parseHTTPRequestHeader(s: str.Str) : lang.Result<HTTPRequestHeader, HTTPHeaderParseError> {
    let first_line_end = s.find("\r\n")
    if (first_line_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.NO_FIRST_LINE)
    }
    let first_line = s.substring(0, first_line_end)
    let method_end = first_line.find(" ")
    if (method_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_METHOD)
    }
    let method = first_line.substring(0, method_end)
    let target_start = method_end + 1
    let target_end = first_line.find(" ", target_start)
    if (target_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_TARGET)
    }
    let target = first_line.substring(target_start, target_end)
    let version_start = target_end + 1
    if (version_start >= first_line.length) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_VERSION)
    }
    let version = first_line.substring(version_start, first_line.length)
    let headers = hashMap.HashMap<str.Str, str.Str>()
    let header_start = first_line_end + 2
    while (header_start < s.length) {
        let header_end = s.find("\r\n", header_start)
        if (header_end == -1) {
            break
        }
        let header_line = s.substring(header_start, header_end)
        let colon_index = header_line.find(":")
        if (colon_index == -1) {
            break
        }
        let header_name = header_line.substring(0, colon_index).lowercase()
        let header_value = header_line.substring(colon_index + 1, header_line.length)
        headers[header_name] = header_value
        header_start = header_end + 2
    }
    return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.ok(HTTPRequestHeader(method, target, version, headers))
}

func parseHTTPResponseHeader(s: str.Str) : lang.Result<HTTPResponseHeader, HTTPHeaderParseError> {
    let first_line_end = s.find("\r\n")
    let first_line = s.substring(0, first_line_end)
    let version_start = 0
    let version_end = first_line.find(" ")
    if (version_end == -1) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_VERSION)
    }
    let version = first_line.substring(version_start, version_end)
    let status_code_start = version_end + 1
    let status_code_end = first_line.find(" ", status_code_start)
    if (status_code_end == -1) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_STATUS_CODE)
    }
    let status_code = str.toInt(first_line.substring(status_code_start, status_code_end))
    let status_message_start = status_code_end + 1
    if (status_message_start >= first_line.length) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_STATUS_MESSAGE)
    }
    let status_message = first_line.substring(status_message_start, first_line.length)
    let headers = hashMap.HashMap<str.Str, str.Str>()
    let header_start = first_line_end + 2
    while (header_start < s.length) {
        let header_end = s.find("\r\n", header_start)
        if (header_end == -1) {
            break
        }
        let header_line = s.substring(header_start, header_end)
        let colon_index = header_line.find(":")
        if (colon_index == -1) {
            break
        }
        let header_name = header_line.substring(0, colon_index).lowercase()
        let header_value = header_line.substring(colon_index + 2, header_line.length)
        headers[header_name] = header_value
        header_start = header_end + 2
    }
    return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.ok(HTTPResponseHeader(version, status_code, status_message, headers))
}

interface HTTPRequestBody {
    contentLength() : int,
    contentType() : str.Str,
    writeTo(writer: socket.AbstractSocket) : none
}

enum HTTPNetworkError {
    SUCCESS,
    INVALID_URI,
    UNKNOWN_PROTOCOL,
    NAME_NOT_RESOLVED,
    CONNECTION_REFUSED,
    CONNECTION_RESET,
    CONNECTION_TIMEOUT,
    INVALID_HTTP_RESPONSE,
    UNKNOWN_ERROR
}

struct HTTPResponse {
    resource: uri.URL,
    header: HTTPResponseHeader,
    socket: socket.AbstractSocket,
    cached_recv: io.ArrayBuffer,
    constructor(resource: uri.URL, socket: socket.AbstractSocket),
    iterate_chunk() : io.ArrayBuffer,
    getch() : char,
    recv_next_raw_response() : lang.Result<io.ArrayBuffer, HTTPNetworkError>,
    recv_text() : lang.Result<str.Str, HTTPNetworkError>,
    recv_header() : lang.Result<HTTPResponse, HTTPNetworkError>,
}

impl HTTPResponse {
    constructor(resource: uri.URL, socket: socket.AbstractSocket) {
        this.resource = resource
        this.socket = socket
    },
    recv_next_raw_response() : lang.Result<io.ArrayBuffer, HTTPNetworkError> {
        let resp = this.socket.recv(1024u)
        if (resp.is_err()) {
            return lang.Result<io.ArrayBuffer, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
        }
        let buf = resp.unwrap()
        if (buf.size == 0) {
            return lang.Result<io.ArrayBuffer, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
        }
        this.cached_recv = buf
        return lang.Result<io.ArrayBuffer, HTTPNetworkError>.ok(buf)
    },
    getch() : char {   
        if (this.cached_recv == null || this.cached_recv.current_pos >= this.cached_recv.size) {
            let result = this.recv_next_raw_response()
            if (result.is_err()) {
                return '\0'
            }
            result.unwrap()
        }
        let ret = this.cached_recv.buf[this.cached_recv.current_pos]
        this.cached_recv.current_pos += 1
        return ret
    },
    iterate_chunk() : io.ArrayBuffer {
        if (this.header.headers.contains("transfer-encoding") == false || this.header.headers["transfer-encoding"] != "chunked") {
            return null
        }
        let chunk_size = 0
        let current_ch = this.getch()
        while ((current_ch >= '0' && current_ch <= '9') || (current_ch >= 'a' && current_ch <= 'f') || (current_ch >= 'A' && current_ch <= 'F')) {
            chunk_size = chunk_size * 16 + math.hextoint(current_ch)
            current_ch = this.getch()
        }
        if (current_ch != '\r' || this.getch() != '\n') {
            return null
        }
        let chunk_data = io.ArrayBuffer(chunk_size)
        let current_pos = 0

        let bytes_to_copy_from_cache = math.min(chunk_size, this.cached_recv.size - this.cached_recv.current_pos)

        if (bytes_to_copy_from_cache > 0) {
            runtime.memcpy(runtime.runtime_get_string_array_data_pointer(chunk_data.buf), runtime.runtime_get_string_array_data_pointer(this.cached_recv.buf) + this.cached_recv.current_pos, bytes_to_copy_from_cache)
        }

        current_pos = bytes_to_copy_from_cache
        this.cached_recv.current_pos += bytes_to_copy_from_cache

        while (current_pos < chunk_size) {
            let result = this.recv_next_raw_response()
            if (result.is_err()) {
                return null
            }
            let buf = result.unwrap()
            if (buf.size == 0) {
                return null
            }
            // if current_pos + buf.size is larger than chunk_size, we need to move its position to the end_pos and break
            let actual_read = math.min(chunk_size - current_pos, buf.size)
            runtime.memcpy(runtime.runtime_get_string_array_data_pointer(chunk_data.buf) + current_pos, runtime.runtime_get_string_array_data_pointer(buf.buf), actual_read)
            current_pos += actual_read
            if (actual_read < buf.size) {
                this.cached_recv.current_pos = actual_read
            }
        }
        // all data received, return
        if (this.getch() != '\r' || this.getch() != '\n') {
            return null
        }
        return chunk_data
    },
    recv_text() : lang.Result<str.Str, HTTPNetworkError> {
        // check if chunked encoding is used
        if (this.header.headers.contains("transfer-encoding") != false && this.header.headers["transfer-encoding"] == "chunked") {
            let final = str.Str(1024u)
            while (true) {
                let chunk = this.iterate_chunk()
                if (chunk == null) {
                    return lang.Result<str.Str, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
                }
                if (chunk.size == 0) {
                    break
                }
                final += chunk.buf
            }
            return lang.Result<str.Str, HTTPNetworkError>.ok(final)
        } elif (this.header.headers.contains("content-length") != false) {
            let content_length = str.toInt(this.header.headers["content-length"])
            if (content_length == 0) {
                return lang.Result<str.Str, HTTPNetworkError>.ok("")
            }
            let content = str.Str(content_length as unsigned)
            let current_pos = 0
            // if content length is larger than the remaining data, we need to read more data from the socket, but before that, we read the remaining data into the content buffer
            runtime.memcpy(runtime.runtime_get_string_array_data_pointer(content.data), runtime.runtime_get_string_array_data_pointer(this.cached_recv.buf) + this.cached_recv.current_pos, this.cached_recv.size - this.cached_recv.current_pos)
            current_pos = this.cached_recv.size - this.cached_recv.current_pos
            while (current_pos < content_length) {
                let result = this.recv_next_raw_response()
                if (result.is_err()) {
                    return lang.Result<str.Str, HTTPNetworkError>.err(result.unwrap_err())
                }
                let buf = result.unwrap()
                if (buf.size == 0) {
                    return lang.Result<str.Str, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
                }
                let actual_read = math.min((content_length - current_pos) as unsigned, buf.size as unsigned)
                runtime.memcpy(runtime.runtime_get_string_array_data_pointer(content.data) + current_pos, runtime.runtime_get_string_array_data_pointer(buf.buf), actual_read)
                current_pos += actual_read
                if (actual_read < buf.size) {
                    this.cached_recv.current_pos = actual_read
                    break
                }
            }
            content.length = content_length
            return lang.Result<str.Str, HTTPNetworkError>.ok(content)
        } else {
            let content = str.Str(1024u)
            // if chunk size is larger than the remaining data, we need to read more data from the socket, but before that, we read the remaining data into the chunk buffer
            runtime.memcpy(runtime.runtime_get_string_array_data_pointer(content.data), runtime.runtime_get_string_array_data_pointer(this.cached_recv.buf) + this.cached_recv.current_pos, this.cached_recv.size - this.cached_recv.current_pos)
            content.length = this.cached_recv.size - this.cached_recv.current_pos
            while (true) {
                let result = this.recv_next_raw_response()
                if (result.is_err()) {
                    return lang.Result<str.Str, HTTPNetworkError>.err(result.unwrap_err())
                }
                let buf = result.unwrap()
                if (buf.size == 0) {
                    return lang.Result<str.Str, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_RESET)
                }
                content += buf.buf
                if (buf.size < 1024) {
                    break
                }
            }
            return lang.Result<str.Str, HTTPNetworkError>.ok(content)
        }
    },
    recv_header() : lang.Result<HTTPResponse, HTTPNetworkError> {
        let recv_s = str.Str(1024u)
        let rnrn_match_array = char[4](13, 10, 13, 10)
        let rnrn_start_pos = 0
        let current_ch = this.getch()
        while (current_ch != 0) {
            if (rnrn_match_array[rnrn_start_pos] == current_ch) {
                rnrn_start_pos += 1
                if (rnrn_start_pos == 4) {
                    break
                }
            } else {
                for (let i = 0; i < rnrn_start_pos; i += 1) {
                    recv_s.push(rnrn_match_array[i])
                }
                rnrn_start_pos = 0
                recv_s.push(current_ch)
            }
            current_ch = this.getch()
        }
        recv_s.push(13)
        recv_s.push(10)
        let parsed = parseHTTPResponseHeader(recv_s)
        if (parsed.is_err()) {
            return lang.Result<HTTPResponse, HTTPNetworkError>.err(parsed.unwrap_err())
        }
        this.header = parsed.unwrap()
        return lang.Result<HTTPResponse, HTTPNetworkError>.ok(this)
    }
}

struct HTTPRequest {
    resource: uri.URL,
    header: HTTPRequestHeader,
    socket: socket.AbstractSocket,
    body: HTTPRequestBody,
    cached_recv: io.ArrayBuffer,
    constructor(resource: uri.URL, header: HTTPRequestHeader, body: HTTPRequestBody),
    constructor(resource: uri.URL, header: HTTPRequestHeader),
    send() : lang.Result<HTTPResponse, HTTPNetworkError>,
    set_body(body: HTTPRequestBody) : HTTPRequest,
    set_header(key: str.Str, value: str.Str) : HTTPRequest,
    patch_header() : HTTPRequest,
}



impl HTTPRequest {
    constructor(resource: uri.URL, header: HTTPRequestHeader, body: HTTPRequestBody) {
        this.header = header
        this.body = body
        this.resource = resource
    },
    constructor(resource: uri.URL, header: HTTPRequestHeader) {
        this.header = header
        this.resource = resource
    },
    patch_header() : HTTPRequest {
        if (this.header.headers.contains("content-length") == false && this.body != null) {
            this.header.add_header("content-length", str.Stringable(this.body.contentLength()).to_string())
        }
        if (this.header.headers.contains("content-type") == false && this.body != null) {
            this.header.add_header("content-type", this.body.contentType())
        }
        if (this.header.headers.contains("host") == false) {
            this.header.add_header("host", this.resource.host)
        }
        if (this.header.headers.contains("user-agent") == false) {
            this.header.add_header("user-agent", "hoshi-libhttp/0.1; JerryChou;")
        }
        return this
    },
    send() : lang.Result<HTTPResponse, HTTPNetworkError> {
        let host = socket.resolve_name(this.resource.host)
        if (host.is_err()) {
            return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.NAME_NOT_RESOLVED)
        }
        if (this.resource.protocol == "https") {
            let result = socket.ssl_socket()
            if (result.is_err()) {
                return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_REFUSED)
            }
            this.socket = result.unwrap()
        } elif (this.resource.protocol == "http") {
            let result = socket.socket()
            if (result.is_err()) {
                return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_REFUSED)
            }
            this.socket = result.unwrap()
        } else {
            return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.UNKNOWN_PROTOCOL)
        }
        if (this.socket.connect(host.unwrap(), this.resource.port) != 0) {
            return lang.Result<HTTPResponse, HTTPNetworkError>.err(HTTPNetworkError.CONNECTION_REFUSED)
        }

        this.patch_header()
        let head = this.header.to_string()
        this.socket.send(head.data, head.length)
        if (this.body != null) {
            this.body.writeTo(this.socket)
        }
        return HTTPResponse(this.resource, this.socket).recv_header()
    },
    set_body(body: HTTPRequestBody) : HTTPRequest {
        this.body = body
        return this
    },
    set_header(key: str.Str, value: str.Str) : HTTPRequest {
        this.header.add_header(key, value)
        return this
    }
}

func open(method: str.Str, url: str.Str, headers: hashMap.HashMap<str.Str, str.Str>, body: HTTPRequestBody) : lang.Result<HTTPRequest, HTTPNetworkError> {
    let uri_result = uri.parseURL(url)
    if (uri_result.is_err()) {
        return lang.Result<HTTPRequest, HTTPNetworkError>.err(HTTPNetworkError.INVALID_URI)
    }
    let header = HTTPRequestHeader(method, uri_result.unwrap().target, "HTTP/1.1", headers)
    return lang.Result<HTTPRequest, HTTPNetworkError>.ok(HTTPRequest(uri_result.unwrap(), header, body))
}

func open(method: str.Str, url: str.Str) : lang.Result<HTTPRequest, HTTPNetworkError> {
    let uri_result = uri.parseURL(url)
    if (uri_result.is_err()) {
        return lang.Result<HTTPRequest, HTTPNetworkError>.err(HTTPNetworkError.INVALID_URI)
    }
    let header = HTTPRequestHeader(method, uri_result.unwrap().target, "HTTP/1.1", hashMap.HashMap<str.Str, str.Str>())
    return lang.Result<HTTPRequest, HTTPNetworkError>.ok(HTTPRequest(uri_result.unwrap(), header))
}
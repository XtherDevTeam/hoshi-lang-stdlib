use str "str"
use runtime "runtime"
use lang "builtin"

/**
Error codes

ZIP_ENOINIT -1      // not initialized
ZIP_EINVENTNAME -2  // invalid entry name
ZIP_ENOENT -3       // entry not found
ZIP_EINVMODE -4     // invalid zip mode
ZIP_EINVLVL -5      // invalid compression level
ZIP_ENOSUP64 -6     // no zip 64 support
ZIP_EMEMSET -7      // memset error
ZIP_EWRTENT -8      // cannot write data to entry
ZIP_ETDEFLINIT -9   // cannot initialize tdefl compressor
ZIP_EINVIDX -10     // invalid index
ZIP_ENOHDR -11      // header not found
ZIP_ETDEFLBUF -12   // cannot flush tdefl buffer
ZIP_ECRTHDR -13     // cannot create entry header
ZIP_EWRTHDR -14     // cannot write entry header
ZIP_EWRTDIR -15     // cannot write to central dir
ZIP_EOPNFILE -16    // cannot open file
ZIP_EINVENTTYPE -17 // invalid entry type
ZIP_EMEMNOALLOC -18 // extracting data using no memory allocation
ZIP_ENOFILE -19     // file not found
ZIP_ENOPERM -20     // no permission
ZIP_EOOMEM -21      // out of memory
ZIP_EINVZIPNAME -22 // invalid zip archive name
ZIP_EMKDIR -23      // make dir error
ZIP_ESYMLINK -24    // symlink error
ZIP_ECLSZIP -25     // close archive error
ZIP_ECAPSIZE -26    // capacity size too small
ZIP_EFSEEK -27      // fseek error
ZIP_EFREAD -28      // fread error
ZIP_EFWRITE -29     // fwrite error
ZIP_ERINIT -30      // cannot initialize reader
ZIP_EWINIT -31      // cannot initialize writer
ZIP_EWRINIT -32     // cannot initialize writer from reader
ZIP_EINVAL -33      // invalid argument
ZIP_ENORITER -34    // cannot initialize reader iterator
*/
enum ErrorCode {
    ENOINIT = -1,
    EINVENTNAME = -2,
    ENOENT = -3,
    EINVMODE = -4,
    EINVLVL = -5,
    ENOSUP64 = -6,
    EMEMSET = -7,
    EWRTENT = -8,
    ETDEFLINIT = -9,
    EINVIDX = -10,
    ENOHDR = -11,
    ETDEFLBUF = -12,
    ECRTHDR = -13,
    EWRTHDR = -14,
    EWRTDIR = -15,
    EOPNFILE = -16,
    EINVENTTYPE = -17,
    EMEMNOALLOC = -18,
    ENOFILE = -19,
    ENOPERM = -20,
    EOOMEM = -21,
    EINVZIPNAME = -22,
    EMKDIR = -23,
    ESYMLINK = -24,
    ECLSZIP = -25,
    ECAPSIZE = -26,
    EFSEEK = -27,
    EFREAD = -28,
    EFWRITE = -29,
    ERINIT = -30,
    EWINIT = -31,
    EWRINIT = -32,
    EINVAL = -33,
    ENORITER = -34
}

enum CompressionLevel {
    Default = 6
}

import zip_open(path: ptr, compression_level: int32, mode: char) : unsigned from "builtin"
import zip_close(zip_file: unsigned) : none from "builtin"

import zip_entries_delete(zip_file: unsigned, entry_names: ptr, n: unsigned) : int32 from "builtin"
import zip_entries_deletebyindex(zip_file: unsigned, entry_indexes: unsigned, n: unsigned) : int32 from "builtin"
import zip_strerror(error: int32) : ptr from "builtin"

import zip_entries_total(zip_file: unsigned) : int32 from "builtin"

import zip_entry_openbyindex(zip_file: unsigned, index: int32) : unsigned from "builtin"
import zip_entry_open(zip_file: unsigned, entryname: ptr) : int32 from "builtin"
import zip_entry_close(zip_file: unsigned) : int32 from "builtin"
import zip_entry_index(zip_file: unsigned) : int from "builtin"

import zip_entry_name(zip_file: unsigned) : ptr from "builtin"
import zip_entry_size(zip_file: unsigned) : int32 from "builtin"
import zip_entry_isdir(zip_file: unsigned) : bool from "builtin"
import zip_entry_crc32(zip_file: unsigned) : int32 from "builtin"

import zip_entry_noallocread(zip_file: unsigned, buf: ptr, bufsize: unsigned) : int from "builtin"
import zip_entry_noallocreadwithoffset(zip_file: unsigned, offset: int, bufsize: unsigned, buf: ptr) : int from "builtin"
import zip_entry_write(zip_file: unsigned, buf: ptr, nbytes: unsigned) : int32 from "builtin"

struct ZipFileEntry {
    zip_fp: unsigned,
    name: str.Str,
    size: int,
    is_directory: bool,
    crc32: unsigned,
    entry_index: int,
    constructor(zip_fp: unsigned),
    finalizer(),
    next() : bool,
    read(buf: char[]) : lang.Result<int, str.Str>,
    write(buf: char[]) : lang.Result<int, str.Str>,
    close() : none
}

impl ZipFileEntry {
    constructor(zip_fp: unsigned) {
        this.zip_fp = zip_fp
        this.name = str.Str.from_c_str(zip_entry_name(zip_fp))
        this.size = zip_entry_size(zip_fp)
        this.is_directory = zip_entry_isdir(zip_fp)
        this.crc32 = zip_entry_crc32(zip_fp)
        this.entry_index = zip_entry_index(zip_fp)
    },
    finalizer() {
        if (this.zip_fp != 0) {
            zip_entry_close(this.zip_fp)
            this.zip_fp = 0
        }
    },
    close() : none {
        if (this.zip_fp != 0) {
            zip_entry_close(this.zip_fp)
            this.zip_fp = 0
        }
    },
    read(buf: char[]) : lang.Result<int, str.Str> {
        let nbytes = zip_entry_noallocread(this.zip_fp, runtime.runtime_get_string_array_data_pointer(buf), buf.length)
        if (nbytes < 0) {
            return lang.Result<int, str.Str>.err(str.Str.from_c_str(zip_strerror(nbytes)))
        }
        return lang.Result<int, str.Str>.ok(nbytes)
    },
    write(buf: char[]) : lang.Result<int, str.Str> {
        let nbytes = zip_entry_write(this.zip_fp, runtime.runtime_get_string_array_data_pointer(buf), buf.length)
        if (nbytes < 0) {
            return lang.Result<int, str.Str>.err(str.Str.from_c_str(zip_strerror(nbytes)))
        }
        return lang.Result<int, str.Str>.ok(nbytes)
    },
    next() : bool {
        let res : bool = zip_entry_openbyindex(this.zip_fp, this.entry_index + 1) != 0
        if (res) {
            this.name = str.Str.from_c_str(zip_entry_name(this.zip_fp))
            this.size = zip_entry_size(this.zip_fp)
            this.is_directory = zip_entry_isdir(this.zip_fp)
            this.crc32 = zip_entry_crc32(this.zip_fp)
            this.entry_index = zip_entry_index(this.zip_fp)
        }
        return res
    }
}

struct ZipFile {
    zip_fp: unsigned,
    entry_singleton: ZipFileEntry,
    constructor(zip_fp: unsigned),
    finalizer(),
    entries() : lang.Result<ZipFileEntry, str.Str>,
    total() : int,
    delete(entry_index: int) : int,
    delete(entry_name: str.Str) : int,
    open(entry_name: str.Str) : lang.Result<ZipFileEntry, str.Str>,
    open(entry_index: int) : lang.Result<ZipFileEntry, str.Str>,
    close() : none
}

impl ZipFile {
    constructor(zip_fp: unsigned) {
        this.zip_fp = zip_fp
        if (zip_entries_total(this.zip_fp) != 0) {
            this.entry_singleton = ZipFileEntry(zip_entry_openbyindex(this.zip_fp, 0))
        }
    },
    finalizer() {
        if (this.zip_fp != 0) {
            zip_close(this.zip_fp)
            this.zip_fp = 0
        }
    },
    close() : none {
        if (this.zip_fp != 0) {
            zip_close(this.zip_fp)
        }
        this.zip_fp = 0
    },
    entries() : lang.Result<ZipFileEntry, str.Str> {
        if (this.total() == 0) {
            return lang.Result<ZipFileEntry, str.Str>.err(str.Str("No entries in zip file"))
        }
        return lang.Result<ZipFileEntry, str.Str>.ok(this.entry_singleton)
    },
    total() : int {
        return zip_entries_total(this.zip_fp)
    },
    delete(entry_index: int) : int {
        let entry_indexes = unsigned[1](entry_index)
        return zip_entries_deletebyindex(this.zip_fp, runtime.runtime_get_string_array_data_pointer(entry_indexes), 1)
    },
    delete(entry_name: str.Str) : int {
        let entry_names = unsigned[1](entry_name.c_str())
        return zip_entries_delete(this.zip_fp, runtime.runtime_get_string_array_data_pointer(entry_names), 1)
    },
    open(entry_name: str.Str) : lang.Result<ZipFileEntry, str.Str> {
        let err = zip_entry_open(this.zip_fp, entry_name.c_str())

        if (err < 0) {
            return lang.Result<ZipFileEntry, str.Str>.err(str.Str.from_c_str(zip_strerror(err)))
        }
        this.entry_singleton = ZipFileEntry(this.zip_fp)
        return lang.Result<ZipFileEntry, str.Str>.ok(this.entry_singleton)
    },
    open(entry_index: int) : lang.Result<ZipFileEntry, str.Str> {
        let entry_fp = zip_entry_openbyindex(this.zip_fp, entry_index)
        if (entry_fp == 0) {
            return lang.Result<ZipFileEntry, str.Str>.err(str.Str("Failed to open entry"))
        }
        return lang.Result<ZipFileEntry, str.Str>.ok(ZipFileEntry(entry_fp))
    }
}

func open(path: str.Str, compression_level: CompressionLevel, mode: char) : lang.Result<ZipFile, str.Str> {
    let zip_fp = zip_open(path.c_str(), compression_level, mode)
    if (zip_fp == 0) {
        return lang.Result<ZipFile, str.Str>.err(str.Str("Failed to open zip file"))
    }
    return lang.Result<ZipFile, str.Str>.ok(ZipFile(zip_fp))
}
use lang "builtin"
use io "io"
use hashMap "hashMap"
use str "str"
use vec "vec"
use runtime "runtime"
use math "math"
use console "console"

enum ResultCode {
    SUCCESS = 0,
    INET_ATON_FAIL = -1,
    CONN_FAIL = -2,
    LISTEN_FAIL = -3,
    ACCEPT_FAIL = -4,
    SEND_FAIL = -5,
    RECV_FAIL = -6,
    SSL_CONNECT_FAIL = -7,
    SSL_SEND_FAIL = -8,
    SSL_RECV_FAIL = -9,
    NAME_RESOLVE_FAIL = -10,
}

/* resolve domain name into IP address, the allocated memory should be freed by the caller */
import libnet_resolve(domain_name: ptr) : ptr from "builtin"

/* socket operations*/
import libnet_socket(result: ptr) : int32 from "builtin"
import libnet_socket_connect(fd: int32, ipAddr: ptr, port: short) : int32 from "builtin"
import libnet_socket_bind(fd: int32, ipAddr: ptr, port: short) : int32 from "builtin"
import libnet_socket_listen(fd: int32, backlog: int32) : int32 from "builtin"
import libnet_socket_accept(fd: int32, clientAddr: ptr, clientAddrLen: ptr) : int32 from "builtin"
import libnet_socket_send(fd: int32, buf: ptr, len: unsigned, sendFlag: int32) : int32 from "builtin"
import libnet_socket_recv(fd: int32, buf: ptr, len: unsigned, recvFlag: int32) : int32 from "builtin"
import libnet_socket_close(fd: int32) : none from "builtin"

/* SSL operations */
import libnet_ssl_connect(fd: int32) : unsigned from "builtin"
import libnet_ssl_send(fd: unsigned, data: ptr, len: unsigned) : int32 from "builtin"
import libnet_ssl_recv(fd: unsigned, dest: ptr, len: unsigned) : int32 from "builtin"
import libnet_ssl_close(fd: unsigned) : none from "builtin"

struct Socket {
    fd: unsigned,
    send_flag: int,
    recv_flag: int,
    constructor(),
    constructor(fd: unsigned, send_flag: int, recv_flag: int),
    finalizer(),
    connect(addr: str.Str, port: short) : ResultCode,
    bind(addr: str.Str, port: short) : ResultCode,
    listen(backlog: int) : ResultCode,
    accept() : lang.Result<Socket, ResultCode>,
    send(data: char[], length: unsigned) : lang.Result<int, ResultCode>,
    send(data: char[]) : lang.Result<int, ResultCode>,
    recv(length: unsigned) : lang.Result<io.ArrayBuffer, ResultCode>,
    close() : none
}

impl Socket {
    constructor() {
        this.fd = 0
        this.send_flag = 0
        this.recv_flag = 0
    },
    constructor(fd: unsigned, send_flag: int, recv_flag: int) {
        this.fd = fd
        this.send_flag = send_flag
        this.recv_flag = recv_flag
    },
    finalizer() {
        if (this.fd > 0) {
            libnet_socket_close(this.fd)
            this.fd = 0
        }
    },
    connect(addr: str.Str, port: short) : ResultCode {
        return libnet_socket_connect(this.fd, runtime.runtime_get_string_array_data_pointer(addr.data), port)
    },
    bind(addr: str.Str, port: short) : ResultCode {
        return libnet_socket_bind(this.fd, addr.data, port)
    },
    listen(backlog: int) : ResultCode {
        return libnet_socket_listen(this.fd, backlog)
    },
    accept() : lang.Result<Socket, ResultCode> {
        let clientAddrLen = new short[1](0)
        let clientAddr = new char[16](0)
        let rc = libnet_socket_accept(this.fd, 0, 0)
        if (rc < 0) {
            return lang.Result<Socket, ResultCode>.err(rc)
        } else {
            return lang.Result<Socket, ResultCode>.ok(Socket(rc, this.send_flag, this.recv_flag))
        }
    },
    send(data: char[], length: unsigned) : lang.Result<int, ResultCode> {
        let rc = libnet_socket_send(this.fd, runtime.runtime_get_string_array_data_pointer(data), length, this.send_flag)
        if (rc < 0) {
            return lang.Result<int, ResultCode>.err(rc)
        } else {
            return lang.Result<int, ResultCode>.ok(rc)
        }
    },
    send(data: char[]) : lang.Result<int, ResultCode> {
        let rc = libnet_socket_send(this.fd, runtime.runtime_get_string_array_data_pointer(data), data.length, this.send_flag)
        if (rc < 0) {
            return lang.Result<int, ResultCode>.err(rc)
        } else {
            return lang.Result<int, ResultCode>.ok(rc)
        }
    },
    recv(length: unsigned) : lang.Result<io.ArrayBuffer, ResultCode> {
        let buf = new char[length](0)
        let rc = libnet_socket_recv(this.fd, runtime.runtime_get_string_array_data_pointer(buf), length, this.recv_flag)
        if (rc < 0) {
            return lang.Result<io.ArrayBuffer, ResultCode>.err(rc)
        } else {
            let composedBuf = io.ArrayBuffer(buf)
            composedBuf.size = rc
            return lang.Result<io.ArrayBuffer, ResultCode>.ok(composedBuf)
        }
    },
    close() : none {
        if (this.fd != 0) {
            libnet_socket_close(this.fd)
            this.fd = 0
        }
    }
}

func socket() : lang.Result<Socket, ResultCode> {
    let fd = unsigned[1](0)
    let rc = libnet_socket(runtime.runtime_get_string_array_data_pointer(fd))
    if (rc != 0) {
        return lang.Result<Socket, ResultCode>.err(rc)
    } else {
        return lang.Result<Socket, ResultCode>.ok(Socket(fd[0], 0, 0))
    }
}

struct SSLSocket {
    ssl_fd: unsigned,
    send_flag: int,
    recv_flag: int,
    constructor(),
    constructor(ssl_fd: unsigned, send_flag: int, recv_flag: int),
    finalizer(),
    connect(addr: str.Str, port: short) : ResultCode,
    recv(length: unsigned) : lang.Result<io.ArrayBuffer, ResultCode>,
    send(data: char[], length: unsigned) : lang.Result<int, ResultCode>,
    send(data: char[]) : lang.Result<int, ResultCode>,
    close() : none
}

impl SSLSocket {
    constructor() {
        this.ssl_fd = 0
        this.send_flag = 0
        this.recv_flag = 0
    },
    constructor(ssl_fd: unsigned, send_flag: int, recv_flag: int) {
        this.ssl_fd = ssl_fd
        this.send_flag = send_flag
        this.recv_flag = recv_flag
    },
    finalizer() {
        if (this.ssl_fd > 0) {
            libnet_ssl_close(this.ssl_fd)
            this.ssl_fd = 0
        }
    },
    connect(addr: str.Str, port: short) : ResultCode {
        let rc = libnet_socket_connect(this.ssl_fd, addr.data, port)
        if (rc != 0) {
            return rc
        }
        return libnet_ssl_connect(this.ssl_fd)
    },
    recv(length: unsigned) : lang.Result<io.ArrayBuffer, ResultCode> {
        let buf = new char[length](0)
        let rc = libnet_ssl_recv(this.ssl_fd, runtime.runtime_get_string_array_data_pointer(buf), length)
        if (rc < 0) {
            return lang.Result<io.ArrayBuffer, ResultCode>.err(rc)
        } else {
            let composedBuf = io.ArrayBuffer(buf)
            composedBuf.size = rc
            return lang.Result<io.ArrayBuffer, ResultCode>.ok(composedBuf)
        }
    },
    send(data: char[], length: unsigned) : lang.Result<int, ResultCode> {
        let rc = libnet_ssl_send(this.ssl_fd, runtime.runtime_get_string_array_data_pointer(data), length)
        if (rc < 0) {
            return lang.Result<int, ResultCode>.err(rc)
        } else {
            return lang.Result<int, ResultCode>.ok(rc)
        }
    },
    send(data: char[]) : lang.Result<int, ResultCode> {
        let rc = libnet_ssl_send(this.ssl_fd, runtime.runtime_get_string_array_data_pointer(data), data.length)
        if (rc < 0) {
            return lang.Result<int, ResultCode>.err(rc)
        } else {
            return lang.Result<int, ResultCode>.ok(rc)
        }
    },
    close() : none {
        if (this.ssl_fd != 0) {
            libnet_ssl_close(this.ssl_fd)
            this.ssl_fd = 0
        }
    }
}

func ssl_socket() : lang.Result<SSLSocket, ResultCode> {
    let ssl_fd = unsigned[1](0)
    let rc = libnet_socket(runtime.runtime_get_string_array_data_pointer(ssl_fd))
    if (rc != 0) {
        return lang.Result<SSLSocket, ResultCode>.err(rc)
    } else {
        return lang.Result<SSLSocket, ResultCode>.ok(SSLSocket(ssl_fd[0], 0, 0))
    }
}

func resolve_name(domain_name: str.Str) : lang.Result<str.Str, ResultCode> {
    let res = libnet_resolve(runtime.runtime_get_string_array_data_pointer(domain_name.data))
    if (res == 0) {
        return lang.Result<str.Str, ResultCode>.err(ResultCode.NAME_RESOLVE_FAIL)
    } else {
        return lang.Result<str.Str, ResultCode>.ok(str.Str.from_c_str(res))
    }
}

struct URL {
    protocol: str.Str,
    host: str.Str,
    port: short,
    target: str.Str,
    constructor(protocol: str.Str, host: str.Str, port: short, target: str.Str),
    to_string() : str.Str
}

impl URL {
    constructor(protocol: str.Str, host: str.Str, port: short, target: str.Str) {
        this.protocol = protocol
        this.host = host
        this.port = port
        this.target = target
    },
    to_string() : str.Str {
        // return this.protocol + "://" + this.host + ":" + str.Stringable(this.port).to_string() + this.target
        return str.format("{}://{}:{}{}", this.protocol, this.host, this.port as int, this.target)
    }
}

impl URL : str.Stringable {
    to_string() : str.Str {
        return this.to_string()
    }
}

enum URLParseError {
    NO_PROTOCOL,
    NO_HOST,
    INVALID_PORT,
    NO_TARGET
}

func parseURL(s: str.Str) : lang.Result<URL, URLParseError> {
    let protocol_end = s.find("://")
    if (protocol_end == -1) {
        return lang.Result<URL, URLParseError>.err(URLParseError.NO_PROTOCOL)
    }
    let protocol = s.substring(0, protocol_end)
    let host_start = protocol_end + 3
    let host_end = s.find("/", host_start)
    if (host_end == -1) {
        host_end = s.length
    }
    let host = s.substring(host_start, host_end)
    // port is optional and in the host
    let port = 80
    if (host.find(":") != -1) {
        let port_start = host.find(":")
        if (port_start != -1) {
            port = str.toInt(host.substring(port_start + 1, host.length))
            if (port == 0 || port > 65535) {
                return lang.Result<URL, URLParseError>.err(URLParseError.INVALID_PORT)
            }
            host = host.substring(0, port_start)
            if (host.length == 0) {
                return lang.Result<URL, URLParseError>.err(URLParseError.NO_HOST)
            }
        }
    }
    // target is everything after the host
    let target_start = host_end
    if (target_start == -1) {
        target_start = s.length
    }
    let target : str.Str = "/"
    if (target_start != s.length) {
        target = s.substring(target_start, s.length)
    }
    return lang.Result<URL, URLParseError>.ok(URL(protocol, host, port, target))
}

struct HTTPRequestHeader {
    method: str.Str,
    target: str.Str,
    version: str.Str,
    headers: hashMap.HashMap<str.Str, str.Str>,
    constructor(method: str.Str, target: str.Str, version: str.Str, headers: hashMap.HashMap<str.Str, str.Str>),
    to_string() : str.Str
}

struct HTTPResponseHeader {
    version: str.Str,
    status_code: int,
    status_message: str.Str,
    headers: hashMap.HashMap<str.Str, str.Str>,
    constructor(version: str.Str, status_code: int, status_message: str.Str, headers: hashMap.HashMap<str.Str, str.Str>),
    to_string() : str.Str
}

impl HTTPRequestHeader {
    constructor(method: str.Str, target: str.Str, version: str.Str, headers: hashMap.HashMap<str.Str, str.Str>) {
        this.method = method
        this.target = target
        this.version = version
        this.headers = headers
    },
    to_string() : str.Str {
        let first_line = str.format("{} {} {}\r\n", this.method, this.target, this.version)
        let headers : str.Str = ""
        for (let i = 0; i < this.headers.size(); i += 1) {
            headers += str.format("{}: {}\r\n", this.headers.keys()[i], this.headers.values()[i])
        }
        return str.format("{}{}{}", first_line, headers, "\r\n")
    }
}

impl HTTPResponseHeader {
    constructor(version: str.Str, status_code: int, status_message: str.Str, headers: hashMap.HashMap<str.Str, str.Str>) {
        this.version = version
        this.status_code = status_code
        this.status_message = status_message
        this.headers = headers
    },
    to_string() : str.Str {
        let first_line = str.format("{} {} {}\r\n", this.version, this.status_code, this.status_message)
        let headers : str.Str = ""
        for (let i = 0; i < this.headers.size(); i += 1) {
            headers += str.format("{}: {}\r\n", this.headers.keys()[i], this.headers.values()[i])
        }
        return str.format("{}{}{}", first_line, headers, "\r\n")
    }
}

impl HTTPRequestHeader : str.Stringable {
    to_string() : str.Str {
        return this.to_string()
    }
}

impl HTTPResponseHeader : str.Stringable {
    to_string() : str.Str {
        return this.to_string()
    }
}

enum HTTPHeaderParseError {
    NO_FIRST_LINE,
    INVALID_METHOD,
    INVALID_TARGET,
    INVALID_VERSION,
    INVALID_STATUS_CODE,
    INVALID_STATUS_MESSAGE
}

func parseHTTPRequestHeader(s: str.Str) : lang.Result<HTTPRequestHeader, HTTPHeaderParseError> {
    let first_line_end = s.find("\r\n")
    if (first_line_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.NO_FIRST_LINE)
    }
    let first_line = s.substring(0, first_line_end)
    let method_end = first_line.find(" ")
    if (method_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_METHOD)
    }
    let method = first_line.substring(0, method_end)
    let target_start = method_end + 1
    let target_end = first_line.find(" ", target_start)
    if (target_end == -1) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_TARGET)
    }
    let target = first_line.substring(target_start, target_end)
    let version_start = target_end + 1
    if (version_start >= first_line.length) {
        return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_VERSION)
    }
    let version = first_line.substring(version_start, first_line.length)
    let headers = hashMap.HashMap<str.Str, str.Str>()
    let header_start = first_line_end + 2
    while (header_start < s.length) {
        let header_end = s.find("\r\n", header_start)
        if (header_end == -1) {
            break
        }
        let header_line = s.substring(header_start, header_end)
        let colon_index = header_line.find(":")
        if (colon_index == -1) {
            break
        }
        let header_name = header_line.substring(0, colon_index).lowercase()
        let header_value = header_line.substring(colon_index + 1, header_line.length)
        headers[header_name] = header_value
        header_start = header_end + 2
    }
    return lang.Result<HTTPRequestHeader, HTTPHeaderParseError>.ok(HTTPRequestHeader(method, target, version, headers))
}

func parseHTTPResponseHeader(s: str.Str) : lang.Result<HTTPResponseHeader, HTTPHeaderParseError> {
    let first_line_end = s.find("\r\n")
    let first_line = s.substring(0, first_line_end)
    let version_start = 0
    let version_end = first_line.find(" ")
    if (version_end == -1) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_VERSION)
    }
    let version = first_line.substring(version_start, version_end)
    let status_code_start = version_end + 1
    let status_code_end = first_line.find(" ", status_code_start)
    if (status_code_end == -1) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_STATUS_CODE)
    }
    let status_code = str.toInt(first_line.substring(status_code_start, status_code_end))
    let status_message_start = status_code_end + 1
    if (status_message_start >= first_line.length) {
        return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.err(HTTPHeaderParseError.INVALID_STATUS_MESSAGE)
    }
    let status_message = first_line.substring(status_message_start, first_line.length)
    let headers = hashMap.HashMap<str.Str, str.Str>()
    let header_start = first_line_end + 2
    while (header_start < s.length) {
        let header_end = s.find("\r\n", header_start)
        if (header_end == -1) {
            break
        }
        let header_line = s.substring(header_start, header_end)
        let colon_index = header_line.find(":")
        if (colon_index == -1) {
            break
        }
        let header_name = header_line.substring(0, colon_index).lowercase()
        let header_value = header_line.substring(colon_index + 1, header_line.length)
        headers[header_name] = header_value
        header_start = header_end + 2
    }
    return lang.Result<HTTPResponseHeader, HTTPHeaderParseError>.ok(HTTPResponseHeader(version, status_code, status_message, headers))
}

func urlencode(s: str.Str) : str.Str {
    let hexmap : str.Str = "0123456789ABCDEF"
    let encoded = str.Str(s.length * 2u)
    for (let i = 0; i < s.length; i += 1) {
        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z') || (s[i] >= '0' && s[i] <= '9') || s[i] == '-' || s[i] == '_' || s[i] == '.' || s[i] == '~') {
            encoded.push(s[i])
        } elif (s[i] == ' ') {
            encoded.push('%')
            encoded.push('2')
            encoded.push('0')
        } else {
            encoded.push('%')
            // console.print(str.format("WTF: {} {} {} {} {}\n", s[i] as int, s[i] as int >> 4, s[i] as int & 0xF, hexmap[s[i] >> 4], hexmap[s[i] & 0xF]))
            encoded.push(hexmap[s[i] >> 4])
            encoded.push(hexmap[s[i] & 0xF])
        }
    }
    return encoded
}

func urldecode(s: str.Str) : str.Str {
    let decoded = str.Str(s.length)
    let i = 0
    for (let i = 0; i < s.length; i += 1) {
        if (s[i] == '+') {
            decoded.push(' ')
        } elif (s[i] == '%') {
            let hex_start = i + 1
            let hex_end = i + 2
            if (hex_end > s.length) {
                break
            }
            decoded.push(math.hextoint(s[hex_start]) << 4 | math.hextoint(s[hex_start + 1]))
            i = hex_end
        } else {
            decoded.push(s[i])
        }
    }
    return decoded
}